name: Post Trace Preview Comment (after CI)

on:
  workflow_run:
    workflows: ["AIE Deployment Gemm"]  # must exactly match your CI workflow's name
    types: [completed]

permissions:
  contents: read
  actions: read
  issues: write
  pull-requests: write

concurrency:
  group: comment-${{ github.event.workflow_run.head_sha }}
  cancel-in-progress: true

jobs:
  update-comment:
    # Only proceed for successful pull_request-triggered CI runs
    if: >
      github.event.workflow_run.conclusion == 'success' &&
      github.event.workflow_run.event == 'pull_request'
    runs-on: ubuntu-latest

    steps:
      - name: Install GitHub CLI and tools
        run: |
          sudo apt-get update
          sudo apt-get install -y gh jq unzip

      - name: Capture event fields
        id: evt
        run: |
          echo "repo=${{ github.repository }}" >> "$GITHUB_OUTPUT"
          echo "run_id=${{ github.event.workflow_run.id }}" >> "$GITHUB_OUTPUT"
          echo "workflow_id=${{ github.event.workflow.id }}" >> "$GITHUB_OUTPUT"
          echo "head_sha=${{ github.event.workflow_run.head_sha }}" >> "$GITHUB_OUTPUT"

      - name: Ensure this is the latest successful run for the head_sha
        id: latest_guard
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ steps.evt.outputs.repo }}
          WORKFLOW_ID: ${{ steps.evt.outputs.workflow_id }}
          RUN_ID: ${{ steps.evt.outputs.run_id }}
          HEAD_SHA: ${{ steps.evt.outputs.head_sha }}
        run: |
          # List completed successful runs of this workflow for the same head sha and pull_request event
          runs_json=$(gh api "repos/$REPO/actions/workflows/$WORKFLOW_ID/runs" \
            -F head_sha="$HEAD_SHA" -F event="pull_request" -F status="completed" \
            --jq '.workflow_runs | map(select(.conclusion=="success"))')

          if [[ -z "$runs_json" || "$runs_json" == "[]" ]]; then
            echo "No successful completed runs found for this head_sha. Exiting."
            echo "proceed=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Pick the newest by run_number
          newest_run_id=$(jq -r 'max_by(.run_number) | .id' <<<"$runs_json")
          echo "Newest successful run for sha is $newest_run_id; current run is $RUN_ID"

          if [[ "$newest_run_id" != "$RUN_ID" ]]; then
            echo "This run is not the latest successful one for the sha. Skipping."
            echo "proceed=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "proceed=true" >> "$GITHUB_OUTPUT"

      - name: Short-circuit if not latest
        if: steps.latest_guard.outputs.proceed != 'true'
        run: echo "Not latest successful run for this sha. Nothing to do."

      - name: Determine PR number
        id: pr
        if: steps.latest_guard.outputs.proceed == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Try to read from payload first
          pr_number=$(jq -r '.workflow_run.pull_requests[0].number // empty' "$GITHUB_EVENT_PATH")
          if [[ -z "$pr_number" ]]; then
            # Fallback: look up PRs by commit
            repo="${{ steps.evt.outputs.repo }}"
            sha="${{ steps.evt.outputs.head_sha }}"
            # The pulls-by-commit endpoint may require this accept header
            prs=$(gh api "repos/$repo/commits/$sha/pulls" -H "Accept: application/vnd.github+json")
            pr_number=$(jq -r '.[0].number // empty' <<<"$prs")
          fi

          if [[ -z "$pr_number" ]]; then
            echo "No PR associated with this run. Exiting."
            exit 0
          fi

          echo "PR number is $pr_number"
          echo "pr_number=$pr_number" >> "$GITHUB_OUTPUT"

      - name: Download outputs artifact from this run
        id: dl
        if: steps.latest_guard.outputs.proceed == 'true' && steps.pr.outputs.pr_number
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          artifacts_url=$(jq -r '.workflow_run.artifacts_url' "$GITHUB_EVENT_PATH")
          echo "Artifacts URL: $artifacts_url"

          # Find the artifact named 'outputs'
          artifact_id=$(gh api "$artifacts_url" --jq '.artifacts[] | select(.name=="outputs") | .id' || true)
          if [[ -z "$artifact_id" ]]; then
            echo "No 'outputs' artifact found for this run. Exiting."
            exit 0
          fi
          echo "Found outputs artifact id: $artifact_id"

          gh api "repos/${{ steps.evt.outputs.repo }}/actions/artifacts/$artifact_id/zip" > artifact.zip
          mkdir -p artifact_contents
          unzip -q artifact.zip -d artifact_contents
          echo "downloaded=true" >> "$GITHUB_OUTPUT"

      - name: Comment on PR with image previews
        if: steps.dl.outputs.downloaded == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');

            const prNumber = Number("${{ steps.pr.outputs.pr_number }}");
            const basePath = 'artifact_contents';

            if (!fs.existsSync(basePath)) {
              core.setFailed(`Artifact folder '${basePath}' not found`);
            }

            const folders = fs.readdirSync(basePath).filter(f => {
              try { return fs.statSync(path.join(basePath, f)).isDirectory(); }
              catch { return false; }
            });

            const marker = "## 🔍 Efficiency Trace Preview";
            let body = `${marker}\n`;
            body += `This comment shows \`trace_efficiency_mm.png\` previews from the latest CI artifact for commit \`${{ steps.evt.outputs.head_sha }}\`.\n\n`;

            for (const folder of folders.sort()) {
              const imgPath = path.join(basePath, folder, 'trace_efficiency_mm.png');
              body += `### ${folder}\n`;
              if (fs.existsSync(imgPath)) {
                const imgData = fs.readFileSync(imgPath).toString('base64');
                body += `![${folder}](data:image/png;base64,${imgData})\n\n`;
              } else {
                body += `_No trace_efficiency_mm.png found._\n\n`;
              }
            }

            // Find existing bot comment with marker
            const { data: comments } = await github.rest.issues.listComments({
              ...context.repo,
              issue_number: prNumber,
            });

            const botComment = comments.find(c =>
              c.user?.type === 'Bot' && typeof c.body === 'string' && c.body.includes(marker)
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                ...context.repo,
                comment_id: botComment.id,
                body,
              });
            } else {
              await github.rest.issues.createComment({
                ...context.repo,
                issue_number: prNumber,
                body,
              });
            }
